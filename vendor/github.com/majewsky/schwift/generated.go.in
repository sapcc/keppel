{
	"Account": {
		"Fields": [
			{ "Header": "X-Account-Bytes-Used", "Attribute": "BytesUsed", "Type": "Uint64Readonly" },
			{ "Header": "X-Account-Container-Count", "Attribute": "ContainerCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Account-Meta-", "Attribute": "Metadata", "Type": "Metadata" },
			{ "Header": "X-Account-Meta-Quota-Bytes", "Attribute": "BytesUsedQuota", "Type": "Uint64" },
			{ "Header": "X-Account-Meta-Temp-URL-Key-2", "Attribute": "TempURLKey2", "Type": "String" },
			{ "Header": "X-Account-Meta-Temp-URL-Key", "Attribute": "TempURLKey", "Type": "String" },
			{ "Header": "X-Account-Object-Count", "Attribute": "ObjectCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Timestamp", "Attribute": "CreatedAt", "Type": "UnixTimeReadonly" }
		]
	},
	"Container": {
		"Fields": [
			{ "Header": "X-Container-Bytes-Used", "Attribute": "BytesUsed", "Type": "Uint64Readonly" },
			{ "Header": "X-Container-Meta-", "Attribute": "Metadata", "Type": "Metadata" },
			{ "Header": "X-Container-Meta-Quota-Bytes", "Attribute": "BytesUsedQuota", "Type": "Uint64" },
			{ "Header": "X-Container-Meta-Quota-Count", "Attribute": "ObjectCountQuota", "Type": "Uint64" },
			{ "Header": "X-Container-Meta-Temp-URL-Key-2", "Attribute": "TempURLKey2", "Type": "String" },
			{ "Header": "X-Container-Meta-Temp-URL-Key", "Attribute": "TempURLKey", "Type": "String" },
			{ "Header": "X-Container-Object-Count", "Attribute": "ObjectCount", "Type": "Uint64Readonly" },
			{ "Header": "X-Container-Read", "Attribute": "ReadACL", "Type": "String" },
			{ "Header": "X-Container-Sync-Key", "Attribute": "SyncKey", "Type": "String" },
			{ "Header": "X-Container-Sync-To", "Attribute": "SyncTo", "Type": "String" },
			{ "Header": "X-Container-Write", "Attribute": "WriteACL", "Type": "String" },
			{ "Header": "X-History-Location", "Attribute": "HistoryLocation", "Type": "String" },
			{ "Header": "X-Storage-Policy", "Attribute": "StoragePolicy", "Type": "String" },
			{ "Header": "X-Timestamp", "Attribute": "CreatedAt", "Type": "UnixTimeReadonly" },
			{ "Header": "X-Versions-Location", "Attribute": "VersionsLocation", "Type": "String" }
		]
	},
	"Object": {
		"Fields": [
			{ "Header": "Content-Disposition", "Attribute": "ContentDisposition", "Type": "String" },
			{ "Header": "Content-Encoding", "Attribute": "ContentEncoding", "Type": "String" },
			{ "Header": "Content-Length", "Attribute": "SizeBytes", "Type": "Uint64" },
			{ "Header": "Content-Type", "Attribute": "ContentType", "Type": "String" },
			{ "Header": "Etag", "Attribute": "Etag", "Type": "String" },
			{ "Header": "Last-Modified", "Attribute": "UpdatedAt", "Type": "HTTPTimeReadonly" },
			{ "Header": "X-Delete-At", "Attribute": "ExpiresAt", "Type": "UnixTime" },
			{ "Header": "X-Object-Meta-", "Attribute": "Metadata", "Type": "Metadata" },
			{ "Header": "X-Symlink-Target-Account", "Attribute": "SymlinkTargetAccount", "Type": "String" },
			{ "Header": "X-Symlink-Target", "Attribute": "SymlinkTarget", "Type": "String" },
			{ "Header": "X-Timestamp", "Attribute": "CreatedAt", "Type": "UnixTimeReadonly" }
		]
	}
}
---
/*******************************************************************************
*
* THIS FILE IS AUTOGENERATED.
*
* Edit `generated.go.in` instead and run `make generate` to produce this file.
*
*******************************************************************************/

package schwift

{{- range $htype, $hmeta := . }}

//{{$htype}}Headers contains the headers for a schwift.{{$htype}} instance.
//
//To read and write well-known headers, use the methods on this type.
//To read and write arbitary headers, use the methods on the Headers supertype.
type {{$htype}}Headers struct {
	Headers
}

//New{{$htype}}Headers creates a new {{$htype}}Headers instance. The return value
//will have the Headers attribute initialized to a non-nil map.
func New{{$htype}}Headers() {{$htype}}Headers {
	return {{$htype}}Headers{make(Headers)}
}

//Validate returns MalformedHeaderError if the value of any well-known header
//does not conform to its data type. This is called automatically by Schwift
//when preparing an {{$htype}}Headers instance from a GET/HEAD response, so you
//usually do not need to do it yourself. You will get the validation error from
//the {{$htype}} method doing the request, e.g. Headers().
func (h {{$htype}}Headers) Validate() error {
{{- range $field := $hmeta.Fields }}
	if err := h.{{$field.Attribute}}().validate(); err != nil {
		return err
	}
{{- end }}
	return evadeGolintComplaint1()
}

{{- range $field := $hmeta.Fields }}

//{{$field.Attribute}} provides type-safe access to {{$field.Header}} headers.
func (h {{$htype}}Headers) {{$field.Attribute}}() Field{{$field.Type}} {
	return Field{{$field.Type}}{h.Headers, "{{$field.Header}}"}
}
{{- end }}
{{- end }}

func evadeGolintComplaint1() error {
	return nil
}
